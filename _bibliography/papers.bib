---
---

@string{aps = {American Physical Society,}}

@inproceedings{DBLP:conf/podc/Mirault025,
  author       = {Hugo Mirault and
                  Peter Robinson},
  editor       = {Alkida Balliu and
                  Fabian Kuhn},
  title        = {Brief Announcement: Towards Energy-Efficient Distributed Agreement},
  booktitle    = {Proceedings of the {ACM} Symposium on Principles of Distributed Computing,
                  {PODC} 2025},
  pages        = {428--431},
  publisher    = {{ACM}},
  year         = {2025},
  url          = {https://doi.org/10.1145/3732772.3733554},
  doi          = {10.1145/3732772.3733554},
  biburl       = {https://dblp.org/rec/conf/podc/Mirault025.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org},
  selected     = {true},
  preview      = {podc.jpg},
  abstract     = {
We study fault-tolerant consensus in a variant of the synchronous message passing model,
where, in each round, every node can choose to be awake or asleep. This is known as the 
sleeping model (Chatterjee, Gmyr, Pandurangan PODC 2020) and defines the awake complexity
(also called \emph{energy complexity}), which measures the maximum number of rounds that
any node is awake throughout the execution. Only awake nodes can send and receive messages
in a given round and all messages sent to sleeping nodes are lost. We present new deterministic
consensus algorithms that tolerate up to $f<n$ crash failures, where $n$ is the number of nodes.
Our algorithms match the optimal time complexity lower bound of $f+1$ rounds. For multi-value consensus,
where the input values are chosen from some possibly large set, we achieve an energy complexity of
$\mathcal{O}(\lceil \frac{f^2}{n} \rceil)$ rounds, whereas for binary consensus, we show that 
$\mathcal{O}(\lceil \frac{f}{\sqrt{n}} \rceil)$ rounds are possible.},
  arxiv        = {2506.12282}

}

@inproceedings{DBLP:conf/sirocco/MiraultRTZ25,
  author       = {Hugo Mirault and
                  Peter Robinson and
                  Ming Ming Tan and
                  Xianbin Zhu},
  editor       = {Ulrich Schmid and
                  Roman Kuznets},
  title        = {Brief Announcement: Perfect Matching with Few Link Activations},
  booktitle    = {Structural Information and Communication Complexity - 32nd International
                  Colloquium, {SIROCCO} 2025},
  series       = {Lecture Notes in Computer Science},
  volume       = {15671},
  pages        = {437--443},
  publisher    = {Springer},
  year         = {2025},
  url          = {https://doi.org/10.1007/978-3-031-91736-3\_28},
  doi          = {10.1007/978-3-031-91736-3\_28},
  timestamp    = {Tue, 10 Jun 2025 17:38:38 +0200},
  biburl       = {https://dblp.org/rec/conf/sirocco/MiraultRTZ25.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org},
  arxiv        = {2506.06102},
  preview      = {sirocco.png},
  abstract     = {
We consider the problem of computing a perfect matching problem
in a synchronous distributed network, where the network topology corresponds 
to a complete bipartite graph. The communication between nodes is restricted 
to activating communication links, which means that instead of sending messages
containing a number of bits, each node can only send a pulse over some of its 
incident links in each round. In the port numbering model, where nodes are unaware
of their neighbor's IDs, we give a randomized algorithm that terminates in $O(\log n)$ 
rounds and has a pulse complexity of O(nlogn), which corresponds to the number of pulses
sent over all links. We also show that randomness is crucial in the port numbering model, 
as any deterministic algorithm must send at least Ω(n2) messages in the standard LOCAL model,
where the messages can be of unbounded size. Then, we turn our attention to the KT_1 assumption,
where each node starts out knowing its neighbors' IDs. We show that this additional knowledge
enables significantly improved bounds even for deterministic algorithms. First, we give an 
%O(\log n)% time deterministic algorithm that sends only $O(n)$ pulses. Finally,
we apply this algorithm recursively to obtain an exponential reduction in the time
complexity to $O(\log^∗ n \log \log n)$, while slightly increasing the pulse complexity to $O(n \log^∗ n)$.
All our bounds also hold in the standard CONGEST model with single-bit messages.}
}
